# java-janggi

장기 미션 저장소

### 초기화

- [x] 장기판에 말들에 대한 초기 배치 상태를 결정한다.
- [x] 장기판에 초기 배치 상태에 맞게 모든 말을 생성한다.

### 턴

- [x] 기물을 움직이고 나면 다음 팀의 턴으로 변경한다.

### 이동

- [x] 이동하려는 기물이 턴에 맞는 팀인지 확인한다.
- [x] 좌표를 받아 이동할 수 있는지 확인한다.
- [x] 보드에서 기물의 위치를 바꾼다.

### 입출력

- [x] 장기판을 출력한다.
- [x] 사용자로부터 좌표를 입력받고 이동한다.

### 고려해야할 것

- ✅ 장기의 말(駒)들은 어떻게 객체로 나누어야 하는가? && ✅ 각 말의 이동 규칙을 어떻게 설계할 것인가?


- **초기 설계**
    - ~~-장기의 말의 구현체의 책임으로 설계한다.~~
    - ~~장기의 말(駒)이라는 추상 객체를 구현하는 구현체를 통해 나눈다.~~


- **장기의 말을 상속을 통해 구현하려고 한 이유**
    - 초기에는 추상화된 장기의 기물을 정의하고 각 기물을 이의 구현체로 나누어, 기물의 공통 로직을 추상화하고 추출하려는 시도를 하였다.
    - 이를 위해, 각 구현체에 기물의 적합한 움직임인지 판단하거나, 이동 규칙을 확인하는 등의 책임애서 상속을 통해 재사용과 정제의 이점을 이용하고자 하였다.


- **현실..**
    - 하지만 각 기물 구현체 별로 이동규칙에 대한 공통 로직을 구체화하는 과정이 복잡했고,
    - 이를 단순화하기 위해 "각 구현체가 이동 규칙에 대한 상수를 가지고 있는" 방식을 고려했으나, 추상화를 활용하기 어려웠고 단순히 기물의 구현체가 상수를 보관하는 용도로 사용되었다.
    - 상속의 이점을 어떻게든 활용하기 위해 "각 기물의 이동할 수 없는 위치에 대한 판단 로직을 추상화 된 메서드를 재정의하여 해결할 수 있지 않을까?" 라고도 생각했다.
    - 하지만 현재 요구사항에서는 "포" 같은 특수한 경우에만 정제의 이점을 활용할 수 있다고 판단했고, 이 이점이 크지 않다고 생각했다.
    - 오히려, 개발 과정에서 상속의 비용을 고려했을 때 상속 구조를 포기함으로써 안전성과 속도를 얻을 수 있다고 판단했다.


- **최종 구현 방식**
    - 추후 요구사항이 추가된다면 추상화를 도입하여 재사용성과 정제를 가져가는 것을 염두하고, 현재는 비용이 큰 추상화를 하지 않아 `Piece`라는 단 하나의 클래스만을 사용했다.
    - 또한, 이동 규칙을 `enum`으로 관리하면 코드의 가독성과 유지보수성이 향상될 것이라 판단하여 해당 방식으로 구현하였다.
